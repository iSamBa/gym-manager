name: Deploy

on:
  push:
    branches: [main]
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]
  workflow_dispatch: # Allow manual deployment
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

# Only allow one deployment at a time
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Check if CI passed before deploying
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    outputs:
      ci-passed: ${{ steps.check.outputs.ci-passed }}
    steps:
      - name: Check CI workflow status
        id: check
        run: |
          if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "ci-passed=true" >> $GITHUB_OUTPUT
          else
            echo "ci-passed=false" >> $GITHUB_OUTPUT
            echo "‚ùå CI workflow failed, skipping deployment"
            exit 1
          fi

  prepare-deployment:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    needs: [check-ci]
    # Skip CI check for manual or push triggers, continue even if check-ci was skipped
    if: |
      always() && (
        github.event_name == 'push' || 
        github.event_name == 'workflow_dispatch' || 
        (github.event_name == 'workflow_run' && needs.check-ci.outputs.ci-passed == 'true') ||
        needs.check-ci.result == 'skipped'
      )
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      deployment-id: ${{ steps.deployment.outputs.deployment_id }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: '${{ steps.env.outputs.environment }}',
              description: 'Automated deployment via GitHub Actions',
              auto_merge: false,
              required_contexts: []
            });

            core.setOutput('deployment_id', deployment.data.id);

            return deployment.data.id;

  build-for-deployment:
    name: Build for Deployment
    runs-on: ubuntu-latest
    needs: [prepare-deployment]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production
          # Add environment-specific variables here
          # NEXT_PUBLIC_APP_ENV: ${{ needs.prepare-deployment.outputs.environment }}

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-build
          path: |
            .next/
            public/
            package.json
            package-lock.json
          retention-days: 1

  # Placeholder for actual deployment steps
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [prepare-deployment, build-for-deployment]
    if: needs.prepare-deployment.outputs.environment == 'staging'
    environment: staging
    steps:
      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-build

      - name: Deploy to staging
        run: |
          echo "üöÄ Deploying to staging environment..."
          echo "This is where you would integrate with your hosting provider:"
          echo "- Vercel: vercel --prod"
          echo "- Netlify: netlify deploy --prod"
          echo "- AWS/Azure/GCP: Custom deployment scripts"
          echo "- Docker: Build and push container"

          # Example deployment commands (uncomment and customize):
          # - name: Deploy to Vercel
          #   run: npx vercel --token ${{ secrets.VERCEL_TOKEN }} --prod

          # - name: Deploy to Netlify  
          #   run: npx netlify deploy --prod --auth ${{ secrets.NETLIFY_TOKEN }}

          # - name: Deploy via SSH
          #   uses: appleboy/ssh-action@v1.0.0
          #   with:
          #     host: ${{ secrets.STAGING_HOST }}
          #     username: ${{ secrets.STAGING_USER }}
          #     key: ${{ secrets.STAGING_SSH_KEY }}
          #     script: |
          #       cd /path/to/app
          #       git pull origin main
          #       npm ci
          #       npm run build
          #       pm2 restart app

      - name: Update deployment status (success)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ needs.prepare-deployment.outputs.deployment-id }}',
              state: 'success',
              description: 'Successfully deployed to staging',
              environment_url: 'https://your-staging-url.com'
            });

      - name: Update deployment status (failure)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ needs.prepare-deployment.outputs.deployment-id }}',
              state: 'failure',
              description: 'Deployment to staging failed'
            });

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [prepare-deployment, build-for-deployment]
    if: needs.prepare-deployment.outputs.environment == 'production'
    environment: production
    steps:
      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-build

      - name: Deploy to production
        run: |
          echo "üéØ Deploying to production environment..."
          echo "This is where you would integrate with your production hosting provider"
          echo "Make sure to:"
          echo "- Run additional safety checks"
          echo "- Create deployment rollback plan"
          echo "- Monitor deployment health"
          echo "- Send deployment notifications"

      - name: Update deployment status (success)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ needs.prepare-deployment.outputs.deployment-id }}',
              state: 'success',
              description: 'Successfully deployed to production',
              environment_url: 'https://your-production-url.com'
            });

      - name: Update deployment status (failure)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: '${{ needs.prepare-deployment.outputs.deployment-id }}',
              state: 'failure',
              description: 'Deployment to production failed'
            });

  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [prepare-deployment, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: Run post-deployment checks
        run: |
          echo "üîç Running post-deployment health checks..."
          echo "- Application health endpoint checks"
          echo "- Database connectivity tests"  
          echo "- API endpoint validation"
          echo "- Performance benchmarks"

      - name: Send deployment notification
        run: |
          echo "üì¢ Sending deployment notifications..."
          echo "Environment: ${{ needs.prepare-deployment.outputs.environment }}"
          echo "Status: Deployment completed successfully"
          echo "Commit: ${{ github.sha }}"

          # Add notification integrations here:
          # - Slack webhook
          # - Discord webhook  
          # - Email notifications
          # - Teams webhook

      - name: Create release (production only)
        if: needs.prepare-deployment.outputs.environment == 'production'
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = `v${new Date().toISOString().slice(0,10).replace(/-/g, '')}-${context.sha.slice(0, 7)}`;

            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: `Production Release ${tagName}`,
              body: `üöÄ Production deployment completed\n\nCommit: ${context.sha}\nWorkflow: ${context.workflow}`,
              draft: false,
              prerelease: false
            });
